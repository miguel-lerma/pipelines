---
name: Reusable - Deploy to Azure Container Apps

on:
  workflow_call:
    inputs:
      environment:
        description: "GitHub Environment a aplicar (dev, stg, prd, etc.)"
        type: string
        required: true

      # ---- OIDC / Azure ----
      azure_client_id:
        type: string
        required: true
      azure_tenant_id:
        type: string
        required: true
      azure_subscription_id:
        type: string
        required: true

      # ---- Destino ----
      resource_group:
        type: string
        required: true
      aca_environment:
        type: string
        required: true
      location:
        type: string
        required: true

      # ---- App e imagen ----
      app_name:
        type: string
        required: true
      image_ref:
        type: string
        required: true

      # ---- Ingress/puerto ----
      ingress:
        type: string
        required: true
      target_port:
        type: string
        required: true

      # ---- Escala/recursos ----
      cpu:
        type: string
        required: true
      memory:
        type: string
        required: true
      min_replicas:
        type: string
        required: true
      max_replicas:
        type: string
        required: true

      # ---- Opcionales ----
      extra_env:
        description: "Variables de entorno l√≠nea por l√≠nea (KEY=VALUE)"
        type: string
        required: false
      acr_login_server:
        description: "login server del ACR (opcional, para setear registry en ACA)"
        type: string
        required: false
      acr_identity_client_id:
        description: "Client ID de la identidad (UserAssigned) con permiso de pull en ACR (opcional)"
        type: string
        required: false

    secrets: {}

defaults:
  run:
    shell: bash

jobs:
  deploy:
    name: Deploy ${{ inputs.environment }}
    # LIGA el job al Environment del repo que llama (dev/stg/prd)
    environment: ${{ inputs.environment }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    # Evita despliegues concurrentes al mismo app+env
    concurrency:
      group: aca-${{ inputs.app_name }}-${{ inputs.environment }}
      cancel-in-progress: true

    steps:
      - name: Checkout repo (caller)
        uses: actions/checkout@v4

      # --- Lint opcional (del repo caller) ---
      - name: Write .yamllint config
        run: |
          cat > .yamllint.yml <<'CFG'
          extends: default
          rules:
            document-start:
              present: true
            trailing-spaces:
              level: error
            new-line-at-end-of-file:
              level: error
            # Reglas ruidosas para GH expressions:
            colons: disable
            braces: disable
            line-length: disable
            truthy: disable
            brackets: disable
            comments: disable
            indentation: disable
          CFG

      - name: yamllint (YAML format)
        uses: ibiqlik/action-yamllint@v3
        with:
          file_or_dir: .github/workflows
          format: github
          strict: true
          no_warnings: false

      - name: actionlint (GHA syntax)
        uses: rhysd/actionlint@v1.6.27
        with:
          shellcheck: false

      # --- Login Azure con OIDC ---
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ inputs.azure_client_id }}
          tenant-id: ${{ inputs.azure_tenant_id }}
          subscription-id: ${{ inputs.azure_subscription_id }}

      # Asegurar extensi√≥n de ACA (idempotente)
      - name: Ensure Azure CLI containerapp extension
        run: |
          set -euo pipefail
          if ! az extension show --name containerapp >/dev/null 2>&1; then
            az extension add --name containerapp -y
          else
            az extension update --name containerapp -y || true
          fi

      # --- VALIDACI√ìN: no crear nada, solo comprobar que existe ---
      - name: Validate existing infra (no mutations)
        env:
          RESOURCE_GROUP: ${{ inputs.resource_group }}
          ACA_ENVIRONMENT: ${{ inputs.aca_environment }}
          LOCATION: ${{ inputs.location }}
          APP_NAME: ${{ inputs.app_name }}
          ACR_LOGIN_SERVER: ${{ inputs.acr_login_server }}
        run: |
          set -euo pipefail
          : "${RESOURCE_GROUP:?missing input 'resource_group'}"
          : "${ACA_ENVIRONMENT:?missing input 'aca_environment'}"
          : "${LOCATION:?missing input 'location'}"
          : "${APP_NAME:?missing input 'app_name'}"

          echo "üîé Validando Resource Group..."
          if ! az group show -n "$RESOURCE_GROUP" -o none; then
            echo "‚ùå Resource group '$RESOURCE_GROUP' no existe. Este workflow NO crea infraestructura."
            exit 2
          fi

          echo "üîé Validando ACA Environment..."
          if ! az containerapp env show -g "$RESOURCE_GROUP" -n "$ACA_ENVIRONMENT" -o none; then
            echo "‚ùå ACA env '$ACA_ENVIRONMENT' no existe en RG '$RESOURCE_GROUP'. Cr√©alo fuera del pipeline."
            exit 2
          fi

          echo "üîé Validando Container App..."
          if ! az containerapp show -g "$RESOURCE_GROUP" -n "$APP_NAME" -o none; then
            echo "‚ùå La Container App '$APP_NAME' no existe en RG '$RESOURCE_GROUP'. Cr√©ala fuera del pipeline."
            exit 2
          fi

          if [[ -n "${ACR_LOGIN_SERVER:-}" ]]; then
            ACR_NAME="${ACR_LOGIN_SERVER%%.*}"
            echo "üîé Validando ACR '$ACR_NAME'..."
            if ! az acr show -n "$ACR_NAME" -o none; then
              echo "‚ùå ACR '$ACR_NAME' no existe. Cr√©alo/config√∫ralo fuera del pipeline."
              exit 2
            fi
          fi

      - name: Build env var block
        id: envblk
        run: |
          set -euo pipefail
          PARAMS=()
          if [[ -n "${{ inputs.extra_env }}" ]]; then
            # Acepta m√∫ltiples l√≠neas KEY=VALUE
            while IFS= read -r line; do
              [[ -z "$line" ]] && continue
              PARAMS+=( --set-env-vars "$line" )
            done <<< "${{ inputs.extra_env }}"
          fi
          # Serializa el array para recuperarlo luego
          printf '%s\0' "${PARAMS[@]}" > envparams.bin
          echo "file=envparams.bin" >> "$GITHUB_OUTPUT"

      # --- Solo actualizaci√≥n de app existente ---
      - name: Update existing Container App
        env:
          RESOURCE_GROUP: ${{ inputs.resource_group }}
          APP_NAME: ${{ inputs.app_name }}
          IMAGE_REF: ${{ inputs.image_ref }}
          INGRESS: ${{ inputs.ingress }}
          TARGET_PORT: ${{ inputs.target_port }}
          CPU: ${{ inputs.cpu }}
          MEMORY: ${{ inputs.memory }}
          MIN_REPLICAS: ${{ inputs.min_replicas }}
          MAX_REPLICAS: ${{ inputs.max_replicas }}
          ACR_LOGIN_SERVER: ${{ inputs.acr_login_server }}
          ACR_IDENTITY_CLIENT_ID: ${{ inputs.acr_identity_client_id }}
        run: |
          set -euo pipefail
          # Recupera los --set-env-vars serializados
          readarray -d '' ENV_PARAMS < "${{ steps.envblk.outputs.file }}"

          # (Opcional) Configurar registry de la app si fue provisto
          if [[ -n "${ACR_LOGIN_SERVER:-}" ]]; then
            if [[ -n "${ACR_IDENTITY_CLIENT_ID:-}" ]]; then
              az containerapp registry set \
                -g "$RESOURCE_GROUP" -n "$APP_NAME" \
                --server "$ACR_LOGIN_SERVER" \
                --identity "$ACR_IDENTITY_CLIENT_ID" \
                --yes || true
            else
              az containerapp registry set \
                -g "$RESOURCE_GROUP" -n "$APP_NAME" \
                --server "$ACR_LOGIN_SERVER" \
                --yes || true
            fi
          fi

          echo "üöÄ Actualizando imagen y configuraci√≥n..."
          az containerapp update \
            -g "$RESOURCE_GROUP" \
            -n "$APP_NAME" \
            --image "$IMAGE_REF" \
            --ingress "$INGRESS" \
            --target-port "$TARGET_PORT" \
            --cpu "$CPU" \
            --memory "$MEMORY" \
            --min-replicas "$MIN_REPLICAS" \
            --max-replicas "$MAX_REPLICAS" \
            "${ENV_PARAMS[@]}"

          echo "‚úÖ Despliegue (update) completado."
