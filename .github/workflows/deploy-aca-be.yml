---
name: CD - Deploy Backend to Azure Container Apps (Reusable)

on:
  workflow_call:
    inputs:
      environment:
        description: "dev | qa | prd"
        required: true
        type: string
      resource_group:
        required: true
        type: string
      location:
        required: true
        type: string
      aca_env:
        required: true
        type: string
      aca_be_name:
        required: true
        type: string
      registry_login_server:
        description: "p.ej. itxzacrlab01.azurecr.io"
        required: true
        type: string
      image_repo:
        description: "repo de imagen en ACR, p.ej. archetype-back"
        required: true
        type: string
      sha:
        description: "sha del commit: <40 hex> (se usa como tag sha-<40>)"
        required: true
        type: string
      ingress:
        description: "internal recomendado para BE"
        default: internal
        type: string
      target_port:
        default: "8080"
        type: string
      cpu:
        default: "0.25"
        type: string
      memory:
        default: "0.5Gi"
        type: string
      min_replicas:
        default: "1"
        type: string
      max_replicas:
        default: "1"
        type: string
      app_env:
        description: "APP_ENV para BE (dev|qa|production)"
        required: true
        type: string

      # ========== Key Vault Integration (OPCIONAL) ==========
      enable_kv:
        description: "Enable Key Vault secret injection"
        type: boolean
        default: false
        required: false
      kv_name:
        description: "Key Vault name (ej: itxzakvlab01)"
        type: string
        default: ""
        required: false
      kv_resource_group:
        description: "RG del Key Vault (si difiere del app, usa el mismo por default)"
        type: string
        default: ""
        required: false
      kv_required:
        description: "Fail si falta secreto en KV (true=PRD, false=DEV)"
        type: boolean
        default: true
        required: false
      kv_secret_refs:
        description: "Space-separated ENV=secret pairs (ej: 'DB_URL=db-url DB_PASS=db-password')"
        type: string
        default: ""
        required: false

permissions:
  id-token: write
  contents: read

concurrency:
  group: cd-be-${{ inputs.environment }}-${{ inputs.sha }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy BE ‚Üí ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          environment: azurecloud
          allow-no-subscriptions: false
          audience: api://AzureADTokenExchange

      - name: Meta (image ref / ACR name)
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          REGISTRY="${{ inputs.registry_login_server }}"
          IMAGE_REPO="${{ inputs.image_repo }}"
          SHA="${{ inputs.sha }}"
          IMAGE_REF="${REGISTRY}/${IMAGE_REPO}:sha-${SHA}"
          ACR_NAME="${REGISTRY%%.azurecr.io}"
          {
            echo "REGISTRY=${REGISTRY}"
            echo "IMAGE_REF=${IMAGE_REF}"
            echo "ACR_NAME=${ACR_NAME}"
          } >> "$GITHUB_OUTPUT"

      - name: Ensure containerapp extension
        uses: azure/CLI@v2
        with:
          inlineScript: az extension add -n containerapp --upgrade || true

      - name: Preflight (RG / Env)
        shell: bash
        run: |
          set -euo pipefail
          az group show -n "${{ inputs.resource_group }}" -o none
          az containerapp env show -g "${{ inputs.resource_group }}" -n "${{ inputs.aca_env }}" -o none || \
          az containerapp env create -g "${{ inputs.resource_group }}" -n "${{ inputs.aca_env }}" -l "${{ inputs.location }}" -o none

      - name: Ensure MI + AcrPull + Registry binding (si existe el app)
        shell: bash
        run: |
          set -euo pipefail
          RG="${{ inputs.resource_group }}"
          APP="${{ inputs.aca_be_name }}"
          ACR_NAME="${{ steps.meta.outputs.ACR_NAME }}"
          ACR_ID="$(az acr show -n "$ACR_NAME" -g "$RG" --query id -o tsv)"

          if az containerapp show -g "$RG" -n "$APP" >/dev/null 2>&1; then
            MI="$(az containerapp show -g "$RG" -n "$APP" --query "identity.principalId" -o tsv)"
            if [[ -z "$MI" || "$MI" == "None" ]]; then
              az containerapp identity assign -g "$RG" -n "$APP" --system-assigned -o none
              MI="$(az containerapp show -g "$RG" -n "$APP" --query "identity.principalId" -o tsv)"
            fi

            HAS_ROLE="$(az role assignment list --assignee "$MI" --role "AcrPull" --scope "$ACR_ID" --query "length(@)" -o tsv)"
            if [[ "$HAS_ROLE" == "0" ]]; then
              az role assignment create --assignee "$MI" --role "AcrPull" --scope "$ACR_ID" -o none
            fi

            az containerapp registry set \
              -g "$RG" -n "$APP" \
              --server "${{ steps.meta.outputs.REGISTRY }}" \
              --identity system -o none || true
          fi

      # ========== NUEVO STEP: Key Vault Integration ==========
      - name: Configure Key Vault Secrets
        if: ${{ inputs.enable_kv == true }}
        shell: bash
        env:
          KV_NAME: ${{ inputs.kv_name }}
          KV_RG: ${{ inputs.kv_resource_group }}
          KV_REQUIRED: ${{ inputs.kv_required }}
          KV_SECRET_REFS: ${{ inputs.kv_secret_refs }}
          RG: ${{ inputs.resource_group }}
          APP: ${{ inputs.aca_be_name }}
        run: |
          set -euo pipefail

          # Validaciones b√°sicas
          if [[ -z "$KV_NAME" ]]; then
            echo "‚ö†Ô∏è enable_kv=true pero kv_name est√° vac√≠o, skipping KV setup"
            echo "KV_SECRETS_ARGS=" >> "$GITHUB_ENV"
            echo "SECRET_ENV_REFS=" >> "$GITHUB_ENV"
            exit 0
          fi

          if [[ -z "$KV_SECRET_REFS" ]]; then
            echo "‚ÑπÔ∏è No hay secretos para inyectar (kv_secret_refs vac√≠o)"
            echo "KV_SECRETS_ARGS=" >> "$GITHUB_ENV"
            echo "SECRET_ENV_REFS=" >> "$GITHUB_ENV"
            exit 0
          fi

          # Usar mismo RG si no se especifica otro
          if [[ -z "$KV_RG" ]]; then
            KV_RG="$RG"
          fi

          echo "üîê Configurando Key Vault: $KV_NAME"

          # 1. Verificar si el app existe
          if ! az containerapp show -g "$RG" -n "$APP" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è App '$APP' no existe a√∫n, se configurar√° KV despu√©s del create"
            echo "KV_SECRETS_ARGS=" >> "$GITHUB_ENV"
            echo "SECRET_ENV_REFS=" >> "$GITHUB_ENV"
            exit 0
          fi

          # 2. Asegurar Managed Identity
          echo "Verificando Managed Identity..."
          MI=$(az containerapp show -g "$RG" -n "$APP" \
            --query "identity.principalId" -o tsv 2>/dev/null || echo "")

          if [[ -z "$MI" || "$MI" == "None" ]]; then
            echo "Asignando System-Assigned Managed Identity..."
            az containerapp identity assign -g "$RG" -n "$APP" --system-assigned -o none
            sleep 5
            MI=$(az containerapp show -g "$RG" -n "$APP" \
              --query "identity.principalId" -o tsv)
          fi

          echo "‚úÖ Managed Identity: $MI"

          # 3. Verificar rol Key Vault Secrets User
          echo "Verificando permisos sobre Key Vault..."
          KV_ID=$(az keyvault show -n "$KV_NAME" -g "$KV_RG" --query id -o tsv)

          HAS_ROLE=$(az role assignment list \
            --assignee "$MI" \
            --role "Key Vault Secrets User" \
            --scope "$KV_ID" \
            --query "length(@)" -o tsv 2>/dev/null || echo "0")

          if [[ "$HAS_ROLE" == "0" ]]; then
            echo "‚ö†Ô∏è Managed Identity no tiene rol 'Key Vault Secrets User'"
            echo "Por favor, asigna manualmente el rol:"
            echo "  az role assignment create --role 'Key Vault Secrets User' \\"
            echo "    --assignee-object-id $MI --assignee-principal-type ServicePrincipal \\"
            echo "    --scope $KV_ID"
            if [[ "$KV_REQUIRED" == "true" ]]; then
              exit 1
            else
              echo "KV_SECRETS_ARGS=" >> "$GITHUB_ENV"
              echo "SECRET_ENV_REFS=" >> "$GITHUB_ENV"
              exit 0
            fi
          else
            echo "‚úÖ Rol ya existe"
          fi

          # 4. Construir secretos de KV y env vars
          echo "Procesando secretos..."
          KV_SECRETS_ARGS=""
          SECRET_ENV_REFS=""

          for pair in $KV_SECRET_REFS; do
            if [[ ! "$pair" =~ ^[A-Z_]+=[a-z0-9-]+$ ]]; then
              echo "‚ö†Ô∏è Formato inv√°lido: '$pair' (ignorando)"
              continue
            fi

            ENV_VAR="${pair%%=*}"
            SECRET_NAME="${pair##*=}"

            # Verificar que el secreto existe en Key Vault
            if az keyvault secret show \
              --vault-name "$KV_NAME" \
              --name "$SECRET_NAME" \
              --query "id" -o tsv >/dev/null 2>&1; then

              echo "  ‚úÖ $ENV_VAR ‚Üí secretref:$SECRET_NAME"

              # Construir argumentos para az containerapp secret set
              KV_SECRETS_ARGS="${KV_SECRETS_ARGS} ${SECRET_NAME}=keyvaultref:https://${KV_NAME}.vault.azure.net/secrets/${SECRET_NAME},identityref:system"

              # Construir env vars que referencian los secretos
              SECRET_ENV_REFS="${SECRET_ENV_REFS} ${ENV_VAR}=secretref:${SECRET_NAME}"
            else
              MSG="Secret '$SECRET_NAME' no existe en Key Vault '$KV_NAME'"

              if [[ "$KV_REQUIRED" == "true" ]]; then
                echo "  ‚ùå ERROR: $MSG"
                exit 1
              else
                echo "  ‚ö†Ô∏è WARNING: $MSG (soft-fail)"
              fi
            fi
          done

          # Guardar para usar en siguiente step
          {
            echo "KV_SECRETS_ARGS<<EOF"
            echo "$KV_SECRETS_ARGS"
            echo "EOF"
            echo "SECRET_ENV_REFS<<EOF"
            echo "$SECRET_ENV_REFS"
            echo "EOF"
          } >> "$GITHUB_ENV"

          echo "‚úÖ Key Vault configurado correctamente"

      - name: Register KV Secrets in Container App
        if: ${{ inputs.enable_kv == true }}
        shell: bash
        env:
          RG: ${{ inputs.resource_group }}
          APP: ${{ inputs.aca_be_name }}
        run: |
          set -euo pipefail

          if [[ -z "${KV_SECRETS_ARGS:-}" ]]; then
            echo "‚ÑπÔ∏è No hay secretos de KV para registrar"
            exit 0
          fi

          # Verificar si el app existe
          if ! az containerapp show -g "$RG" -n "$APP" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è App no existe a√∫n, se registrar√°n secretos durante el create"
            exit 0
          fi

          echo "üì¶ Registrando/actualizando secretos de Key Vault en Container App..."

          # Registrar secretos (az containerapp secret set reemplaza si ya existen)
          eval "az containerapp secret set -g \"$RG\" -n \"$APP\" --secrets $KV_SECRETS_ARGS"

          echo "‚úÖ Secretos registrados/actualizados"

          # Listar para verificar
          echo ""
          echo "üìã Secretos actualmente registrados:"
          az containerapp secret list -g "$RG" -n "$APP" -o table

      - name: Create/Update BE (ACA)
        env:
          IMG: ${{ steps.meta.outputs.IMAGE_REF }}
          RG: ${{ inputs.resource_group }}
          ACA_ENV: ${{ inputs.aca_env }}
          APP: ${{ inputs.aca_be_name }}
          INGRESS: ${{ inputs.ingress }}
          TARGET_PORT: ${{ inputs.target_port }}
          CPU: ${{ inputs.cpu }}
          MEM: ${{ inputs.memory }}
          MIN: ${{ inputs.min_replicas }}
          MAX: ${{ inputs.max_replicas }}
          APP_ENV: ${{ inputs.app_env }}
        shell: bash
        run: |
          set -euo pipefail

          # Crear archivo temporal con env vars
          cat > /tmp/container-envvars.txt <<ENVEOF
          APP_ENV=${APP_ENV}
          PORT=${TARGET_PORT}
          NODE_ENV=production
          LOG_LEVEL=info
          ENVEOF

          # Agregar secret refs de KV si existen
          if [[ -n "${SECRET_ENV_REFS:-}" ]]; then
            echo "üì¶ Agregando secretos de Key Vault..."
            # SECRET_ENV_REFS viene como: "DATABASE_URL=secretref:db-url DATABASE_USER=secretref:db-user ..."
            echo "$SECRET_ENV_REFS" | tr ' ' '\n' >> /tmp/container-envvars.txt
            echo "‚úÖ Secretos agregados"
          fi

          # Mostrar configuraci√≥n final (debug)
          echo "üìã Env vars a configurar:"
          cat /tmp/container-envvars.txt
          echo ""

          # Convertir archivo a argumentos separados por espacios
          ENV_VARS_ARGS=$(cat /tmp/container-envvars.txt | tr '\n' ' ')

          if ! az containerapp show -g "$RG" -n "$APP" >/dev/null 2>&1; then
            echo "üÜï Creando Container App..."
            az containerapp create \
              -g "$RG" -n "$APP" \
              --environment "$ACA_ENV" \
              --image "$IMG" \
              --ingress "$INGRESS" --target-port "$TARGET_PORT" \
              --registry-server "${{ steps.meta.outputs.REGISTRY }}" \
              --registry-identity system \
              --system-assigned \
              --cpu "$CPU" --memory "$MEM" \
              --min-replicas "$MIN" --max-replicas "$MAX" \
              --env-vars $ENV_VARS_ARGS
          else
            echo "üîÑ Actualizando Container App..."
            az containerapp update \
              -g "$RG" -n "$APP" \
              --image "$IMG" \
              --cpu "$CPU" --memory "$MEM" \
              --min-replicas "$MIN" --max-replicas "$MAX" \
              --replace-env-vars $ENV_VARS_ARGS
          fi

          # Cleanup
          rm -f /tmp/container-envvars.txt

          # Verificar configuraci√≥n aplicada
          echo ""
          echo "‚úÖ Verificando env vars aplicadas:"
          az containerapp show -g "$RG" -n "$APP" \
            --query "properties.template.containers[0].env[].{name:name, value:value, secretRef:secretRef}" \
            -o table

      - name: BE internal FQDN (verificaci√≥n)
        shell: bash
        run: |
          set -euo pipefail
          echo "FQDN interno del BE:"
          az containerapp show \
            -g "${{ inputs.resource_group }}" \
            -n "${{ inputs.aca_be_name }}" \
            --query "properties.configuration.ingress.fqdn" -o tsv

      - name: "Post-Deploy Sanity (config efectiva)"
        shell: bash
        env:
          RG: ${{ inputs.resource_group }}
          APP: ${{ inputs.aca_be_name }}
          EXP_CPU: ${{ inputs.cpu }}
          EXP_MEM: ${{ inputs.memory }}
          EXP_MIN: ${{ inputs.min_replicas }}
          EXP_MAX: ${{ inputs.max_replicas }}
          EXP_PORT: ${{ inputs.target_port }}
          EXP_INGRESS: ${{ inputs.ingress }}
          EXP_APP_ENV: ${{ inputs.app_env }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          set -euo pipefail

          if [[ "$ENVIRONMENT" == "dev" ]]; then SOFT_FAIL=1; else SOFT_FAIL=0; fi
          fail_or_warn() {
            if [[ "$SOFT_FAIL" -eq 1 ]]; then
              echo "::warning::$1"
            else
              echo "$1"
              exit 1
            fi
          }
          assert_eq() {
            local exp="$1" act="$2" label="$3"
            if [[ "$exp" != "$act" ]]; then
              fail_or_warn "Mismatch $label: expected '$exp', got '$act'"
            fi
          }

          cpu="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.containers[0].resources.cpu" -o tsv)"
          mem="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.containers[0].resources.memory" -o tsv)"
          min="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.scale.minReplicas" -o tsv || true)"
          max="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.scale.maxReplicas" -o tsv || true)"
          if [[ -z "$min" ]]; then
            min="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.minReplicas" -o tsv || true)"
          fi
          if [[ -z "$max" ]]; then
            max="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.maxReplicas" -o tsv || true)"
          fi
          port="$(az containerapp show -g "$RG" -n "$APP" --query "properties.configuration.ingress.targetPort" -o tsv)"
          ext="$(az containerapp show -g "$RG" -n "$APP" --query "properties.configuration.ingress.external" -o tsv)"
          rev="$(az containerapp show -g "$RG" -n "$APP" --query "properties.configuration.activeRevisionsMode" -o tsv)"
          app_env="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.containers[0].env[?name=='APP_ENV'].value" -o tsv)"
          port_env="$(az containerapp show -g "$RG" -n "$APP" --query "properties.template.containers[0].env[?name=='PORT'].value" -o tsv)"

          if [[ "$EXP_INGRESS" == "external" ]]; then exp_ingress_bool="true"; else exp_ingress_bool="false"; fi

          {
            echo "### BE $APP ‚Äì Config efectiva"
            echo "- CPU: $cpu"
            echo "- Mem: $mem"
            echo "- Min/Max: $min/$max"
            echo "- Ingress externo: $ext (esperado: $exp_ingress_bool)"
            echo "- Target port: $port (esperado: $EXP_PORT)"
            echo "- Revision mode: $rev"
            echo "- APP_ENV env: $app_env (esperado: $EXP_APP_ENV)"
            echo "- PORT env: $port_env (esperado: $EXP_PORT)"
          } >> "$GITHUB_STEP_SUMMARY"

          assert_eq "$EXP_CPU" "$cpu" "CPU"
          assert_eq "$EXP_MEM" "$mem" "memory"
          assert_eq "$EXP_MIN" "$min" "min replicas"
          assert_eq "$EXP_MAX" "$max" "max replicas"
          assert_eq "$EXP_PORT" "$port" "target port"
          assert_eq "$exp_ingress_bool" "$ext" "ingress external/internal"
          assert_eq "$EXP_APP_ENV" "$app_env" "APP_ENV"
          assert_eq "$EXP_PORT" "$port_env" "PORT env"

          echo "‚úÖ BE sanity OK (soft-fail=$SOFT_FAIL)"
